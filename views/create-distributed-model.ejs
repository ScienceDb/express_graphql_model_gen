const _ = require('lodash');

const adapters = require('../adapters/index');
const globals = require('../config/globals');
const helper = require('../utils/helper');

const definition = <%- definition -%>;

let registry = [ <%- registry.map( x => '"'+x+'"') -%> ];

module.exports = class <%- name -%>{

  /**
   * constructor - Creates an instance of the model
   *
   * @param  {obejct} input    Data for the new instances. Input for each field of the model.
   */

  constructor({id <%for(var key in attributes){-%>,<%=key-%><%}-%>}){
      this.id = id;
       <%for(var key in attributes){-%>
         this.<%=key-%> =<%=key-%>;
        <%}-%>
  }

  static get name(){
    return "<%- nameLc -%>";
  }

  static readById(id) {

    let responsibleAdapter = registry.filter( adapter => adapters[adapter].recognizeId(id));

    if(responsibleAdapter.length > 1 ){
      throw new Error("IRI has no unique match");
    }else if(responsibleAdapter.length === 0){
      throw new Error("IRI has no match WS");
    }

    return adapters[responsibleAdapter[0] ].readById(id);

  }

  static countRecords(search){
    let promises = registry.map( adapter =>  adapters[adapter].countRecords(search));

    return Promise.all(promises).then( results =>{
      return results.reduce( (total, current)=> total+current, 0);
    });
  }


  static readAllCursor(search, order, pagination) {

    if(pagination === undefined || (pagination.first!==undefined || pagination.cursor !== undefined)){

      let promises = registry.map( adapter => adapters[adapter].readAllCursor(search, order,pagination) );
      let someHasNextPage = false;
      return Promise.all(promises).then( results => {
        return results.reduce( (total, current)=> {someHasNextPage |=  current.pageInfo.hasNextPage;
          return total.concat(current.edges.map( e =>  e.node))}, [] );
      }).then( nodes => {
          if(order === undefined ){ order = [{field:"id", order:'ASC'}]; }
          if(pagination === undefined ){ pagination = { first : Math.min(globals.LIMIT_RECORDS, nodes.length)  }}

          let ordered_records = helper.orderRecords(nodes, order);
          let pagigated_records = helper.paginateRecords(ordered_records, pagination.first);
          let hasNextPage = ordered_records.length > pagination.first || someHasNextPage;
          return helper.toGraphQLConnectionObject(pagigated_records, this, hasNextPage);
        });

    }else{
      throw new Error("Pagination is expected to be cursor based.You need to specify 'cursor' or 'first' parameters.Please check the documentation.");
    }
  }


  static get definition(){
    return definition;
  }

  static base64Decode(cursor){
    return Buffer.from(cursor, 'base64').toString('utf-8');
  }


  base64Enconde(){
    return Buffer.from(JSON.stringify(this.stripAssociations())).toString('base64');
  }

  stripAssociations(){
    let attributes = Object.keys(<%- name -%>.definition.attributes);
    attributes.push('id');
    let data_values = _.pick(this, attributes);
    return data_values;
  }

  <% let associations_temp = associations["hasMany"]-%>
  <% for(let i=0; i < associations_temp.length; i++){ -%>
    <%=associations_temp[i].name%>ConnectionImpl({search,order,pagination}){
      if(search === undefined)
      {
        return models.<%=associations_temp[i].target_lc%>.readAllCursor({"field" : "<%=associations_temp[i].targetKey%>", "value":{"value":this.id }, "operator": "eq"}, order, pagination);
      }else{
        return models.<%=associations_temp[i].target_lc%>.readAllCursor({"operator":"and", "search":[ {"field" : "<%=associations_temp[i].targetKey%>", "value":{"value":this.id }, "operator": "eq"} , search] }, order, pagination )
      }
    }
  <%}-%>

}
