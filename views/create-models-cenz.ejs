const _ = require('lodash');
const path = require('path');
const models = require(path.join(__dirname, '..', 'models_index.js'));
const axios_general = require('axios');
const FormData = require('form-data');
const fs = require('fs');
const os = require('os');
const uuidv4 = require('uuidv4');
const globals = require('../config/globals');

// An exact copy of the the model definition that comes from the .json file
const definition = <%- definition -%>;

const url = "<%- url -%>";
let axios = axios_general.create();
axios.defaults.timeout = globals.MAX_TIME_OUT;

module.exports = class <%- name -%>{

  /**
   * constructor - Creates an instance of the model stored in webservice
   *
   * @param  {obejct} input    Data for the new instances. Input for each field of the model.
   */

  constructor({<%- idAttribute -%> <%for(var key in attributes){-%>,<%=key-%><%}-%>}){
      this.<%- idAttribute -%> = <%- idAttribute -%>;
       <%for(var key in attributes){-%>
         this.<%=key-%> =<%=key-%>;
        <%}-%>
  }

  static get name(){
    return "<%- nameLc -%>";
  }

  static readById( id ){
    let query = `query readOne<%- nameCp -%>{ readOne<%- nameCp -%>(<%- idAttribute -%>: "${id}"){<%- idAttribute -%> <%for(var key in attributes){-%>
       <%=key %>
     <%}-%> } }`

     return axios.post(url, {query:query}).then(res => {
        //check
        if(res&&res.data&&res.data.data) {
          return new <%- name -%>(res.data.data.readOne<%- nameCp -%>);
        } else {
          throw new Error(`Invalid response from remote cenz-server: ${url}`);
        }
     }).catch(error => {
       error['url'] = url;
       handleError(error);
     });
  }

  static countRecords(search){
    let query = `query count<%- namePlCp -%>($search: search<%- nameCp -%>Input){
      count<%- namePlCp -%>(search: $search)
    }`

    return axios.post(url, {query:query, variables:{search: search}}).then(res=>{
      return {sum: res.data.data.count<%- namePlCp -%>, errors: []};
    }).catch(error =>{
      error['url'] = url;
      handleError(error);
    });
  }

  static readAll(search, order, pagination){
    let query = `query <%- namePl -%>($search: search<%- nameCp -%>Input $pagination: paginationInput $order: [order<%- nameCp -%>Input]){
      <%- namePl -%>(search:$search pagination:$pagination order:$order){<%- idAttribute -%> <%for(var key in attributes){-%>
         <%=key %>
       <%}-%> } }`

       return axios.post(url, {query:query, variables: {search: search, order:order, pagination: pagination}}).then(res =>{
        //check
        if(res&&res.data&&res.data.data) {
          let data = res.data.data.<%- namePl -%> ;
          return data.map(item => {return new <%- name -%>(item) });
        } else {
          throw new Error(`Invalid response from remote cenz-server: ${url}`);
        }
       }).catch(error=>{
         error['url'] = url;
         handleError(error);
       });

  }

  static readAllCursor(search, order, pagination){
    //check valid pagination arguments
    let argsValid = (pagination === undefined) || (pagination.first && !pagination.before && !pagination.last) || (pagination.last && !pagination.after && !pagination.first);
    if (!argsValid) {
      throw new Error('Illegal cursor based pagination arguments. Use either "first" and optionally "after", or "last" and optionally "before"!');
    }

    let query = `query <%- namePl -%>Connection($search: search<%- nameCp -%>Input $pagination: paginationCursorInput $order: [order<%- nameCp -%>Input]){

      <%- namePl -%>Connection(search:$search pagination:$pagination order:$order){ edges{cursor node{  <%- idAttribute -%> <%for(var key in attributes){-%> <%=key %>
       <%}-%>} } pageInfo{startCursor endCursor hasPreviousPage hasNextPage  } } }`

      return axios.post(url, {query:query, variables: {search: search, order:order, pagination: pagination}}).then(res =>{
        //check
        if(res&&res.data&&res.data.data) {
          let data_edges = res.data.data.<%- namePl -%>Connection.edges ;
          let pageInfo = res.data.data.<%- namePl -%>Connection.pageInfo ;

          let edges = data_edges.map( e =>{
            return {
              node: new <%- name -%>(e.node),
              cursor: e.cursor
            }
          })

          return { edges, pageInfo };
        } else {
          throw new Error(`Invalid response from remote cenz-server: ${url}`);
        }
      }).catch(error=>{
        error['url'] = url;
        handleError(error);
      });
  }

  static addOne(input){
    let query = `
        mutation add<%- nameCp _%>(
<%if(!defaultId){-%>
          $<%=idAttribute%>:ID! <%}-%> <%for(var key in editableAttributes){%>
          $<%=key %>:<%= editableAttributes[key]%><%}-%>
        ){
          add<%- nameCp -%>(<%if(!defaultId){-%>
          <%=idAttribute %>:$<%= idAttribute%> <%}-%> <%for(var key in editableAttributes){%>
          <%=key %>:$<%= key%><%}-%>){
            <%- idAttribute -%>
<%for(var key in attributes){-%>
            <%=key %>
<%}-%>
          }
        }`;

    return axios.post(url, {query:query, variables:input}).then(res =>{
      //check
      if(res&&res.data&&res.data.data) {
        return new <%- name -%>(res.data.data.add<%- nameCp -%>);
      } else {
        throw new Error(`Invalid response from remote cenz-server: ${url}`);
      }
    }).catch(error =>{
      error['url'] = url;
      handleError(error);
    });
  }

  static deleteOne(id){
    let query = `
          mutation
            delete<%- nameCp -%>{
              delete<%- nameCp -%>(
                <%- idAttribute -%>: "${id}" )}`;

    return axios.post(url, {query: query}).then(res =>{
      //check
      if(res&&res.data&&res.data.data) {
        return res.data.data.delete<%- nameCp -%>;
      } else {
        throw new Error(`Invalid response from remote cenz-server: ${url}`);
      }
    }).catch(error =>{
      error['url'] = url;
      handleError(error);
    });
  }

  static updateOne(input){
    let query = `
          mutation
            update<%- nameCp-%>(
              $<%- idAttribute -%>:ID! <%for(var key in editableAttributes){%>
              $<%=key %>:<%= editableAttributes[key]%> <%}-%>
            ){
              update<%- nameCp-%>(
                <%- idAttribute -%>:$<%- idAttribute -%> <%for(var key in editableAttributes){%>
                <%=key %>:$<%= key%> <%}-%>
              ){
                <%- idAttribute -%> <%for(var key in attributes){%>
                <%=key %> <%}%>
              }
            }`

    return axios.post(url, {query:query, variables:input}).then(res => {
      //check
      if(res&&res.data&&res.data.data) {
        return new <%- name -%>(res.data.data.update<%- nameCp -%>);
      } else {
        throw new Error(`Invalid response from remote cenz-server: ${url}`);
      }
    }).catch(error =>{
      error['url'] = url;
      handleError(error);
    });
  }

   <%#
  /**
   * Add and remove methods for to-one association where the foreign key
   * is stored in this model and therefore this adapter is the responsible to update the foreign key.
   */
  -%>
  <%- include('./includes/create-models-cenz-fieldMutations', {op: "add"}); %>
  <%- include('./includes/create-models-cenz-fieldMutations', {op: "remove"}); %>

  static bulkAddCsv(context){
    let tmpFile = path.join(os.tmpdir(), uuidv4()+'.csv');

    return context.request.files.csv_file.mv(tmpFile).then(() =>{
      let query = `mutation {bulkAdd<%- nameCp -%>Csv{<%- idAttribute -%>}}`;
      let formData = new FormData();
      formData.append('csv_file', fs.createReadStream(tmpFile));
      formData.append('query', query);

      return axios.post(url, formData,  {
        headers: formData.getHeaders()
      }).then(res =>{
          return res.data.data.bulkAdd<%- nameCp -%>Csv;
        });

    }).catch(error =>{
      error['url'] = url;
      handleError(error);
    });
  }

  static  csvTableTemplate(){
      let query = `query { csvTableTemplate<%- nameCp-%> }`;
      return axios.post(url, {query:query}).then(res =>{
        return res.data.data.csvTableTemplate<%- nameCp-%>;
      }).catch(error =>{
        error['url'] = url;
        handleError(error);
      });
    }

  static get definition(){
    return definition;
  }

  static base64Decode(cursor){
    return Buffer.from(cursor, 'base64').toString('utf-8');
  }

  base64Enconde(){
    return Buffer.from(JSON.stringify(this.stripAssociations())).toString('base64');
  }

  stripAssociations(){
    let attributes = Object.keys(<%- name -%>.definition.attributes);
    <%if( defaultId ){-%>attributes.push('<%- idAttribute -%>'); <%}-%>
    let data_values = _.pick(this, attributes);
    return data_values;
  }

  /**
   * idAttribute - Check whether an attribute "internalId" is given in the JSON model. If not the standard "id" is used instead.
   *
   * @return {type} Name of the attribute that functions as an internalId
   */

  static idAttribute() {
    return <%- name -%>.definition.id.name;
  }

  /**
   * idAttributeType - Return the Type of the internalId.
   *
   * @return {type} Type given in the JSON model
   */

  static idAttributeType() {
    return <%- name -%>.definition.id.type;
  }

  /**
   * getIdValue - Get the value of the idAttribute ("id", or "internalId") for an instance of <%- name -%>.
   *
   * @return {type} id value
   */

  getIdValue() {
    return this[<%- name -%>.idAttribute()]
  }
};
