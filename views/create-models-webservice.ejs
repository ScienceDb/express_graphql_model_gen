const _ = require('lodash');
const path = require('path');
const models = require(path.join(__dirname, '..', 'models_index.js'));

// An exact copy of the the model definition that comes from the .json file
const definition = <%- definition -%>;

module.exports = class <%- name -%>{

  /**
   * constructor - Creates an instance of the model stored in webservice
   *
   * @param  {obejct} input    Data for the new instances. Input for each field of the model.
   */

  constructor({id <%for(var key in attributes){-%>,<%=key-%><%}-%>}){
      this.id = id;
       <%for(var key in attributes){-%>
         this.<%=key-%> =<%=key-%>;
        <%}-%>
  }

  static get name(){
    return "<%- nameLc -%>";
  }

  static readById( id ){
    /*
    YOUR CODE GOES HERE
    */
    throw new Error('readOne<%- nameCp -%> is not implemented');
  }

  static countRecords(search){

    /*
    YOUR CODE GOES HERE
    */
    throw new Error('count<%- namePlCp -%> is not implemented');
  }

  static readAll(search, order, pagination){
    /*
    YOUR CODE GOES HERE
    */
    throw new Error('Read all <%- namePl -%> is not implemented');

  }

  static readAllCursor(search, order, pagination){
    /*
    YOUR CODE GOES HERE
    */
    throw new Error('Read all <%- namePl -%> with cursor based pagination is not implemented');

  }

  static addOne(input){
    /*
    YOUR CODE GOES HERE
    */
    throw new Error('add<%- nameCp -%> is not implemented');
  }

  static deleteOne(id){
    /*
    YOUR CODE GOES HERE
    */
    throw new Error('delete<%- nameCp -%> is not implemented');
  }

  static updateOne(input){
    /*
    YOUR CODE GOES HERE
    */
    throw new Error('update<%- nameCp-%> is not implemented');
  }

  static bulkAddCsv(context){
    /*
    YOUR CODE GOES HERE
    */
    throw new Error('bulkAdd<%- nameCp -%>Csv is not implemented');
  }

  static  csvTableTemplate(){
      /*
      YOUR CODE GOES HERE
      */
      throw new Error('csvTableTemplate<%- nameCp-%> is not implemented');
    }

    <%let associations_one = associations["belongsTo"]-%>
    <% for(let i=0; i < associations_one.length; i++){ -%>

      set_<%=associations_one[i].targetKey%>( value ){
        this.<%=associations_one[i].targetKey%> = value;
      }

      _add<%=associations_one[i].name_cp%>(id){
        /*
        YOUR CODE GOES HERE
        */
        throw new Error('_add<%=associations_one[i].name_cp%> is not implemented');
      }

      _remove<%=associations_one[i].name_cp%>(id){
        /*
        YOUR CODE GOES HERE
        */
        throw new Error('_remove<%=associations_one[i].name_cp%> is not implemented');
      }

    <%=associations_one[i].name%>Impl (search){
        if(search === undefined){
          return models.<%=associations_one[i].target_lc%>.readById(this.<%=associations_one[i].targetKey%>);
        }else{
          /*
          YOUR CODE GOES HERE
          */
          throw new Error('<%=associations_one[i].name%>Impl is not implemented in the model');
        }
      }
    <%}-%>

    <%associations_one = associations["hasOne"]-%>
    <% for(let i=0; i < associations_one.length; i++){ -%>

      _add<%=associations_one[i].name_cp%>(id){
        /*
        YOUR CODE GOES HERE
        */
        throw new Error('_add<%=associations_one[i].name_cp%> is not implemented in the model');
      }

      _remove<%=associations_one[i].name_cp%>(id){
        /*
        YOUR CODE GOES HERE
        */
        throw new Error('_remove<%=associations_one[i].name_cp%> is not implemented in the model');
      }

    <%=associations_one[i].name%>Impl (search){
        if(search === undefined){
          let simple_search = {
            "field": "<%=associations_one[i].targetKey%>",
            "value": {
              "value": this.getIdValue()
            },
            "operator": "eq"
          }

          return models.<%=associations_one[i].target_lc%>.readAll(simple_search)
          .then( found => { if(found){
            return found[0];
          }
            return found;
          })

        }else{
          /*
          YOUR CODE GOES HERE
          */
          throw new Error('<%=associations_one[i].name%>Impl is not implemented in the model');
        }
      }
    <%}-%>



      <% associations_temp = associations["hasMany"]-%>
      <% for(let i=0; i < associations_temp.length; i++){ -%>

        _add<%=associations_temp[i].name_cp%>(ids){
          /*
          YOUR CODE GOES HERE
          */
          throw new Error('_add<%=associations_temp[i].name_cp%> is not implemented in the model');
        }

        _remove<%=associations_temp[i].name_cp%>(ids){
          /*
          YOUR CODE GOES HERE
          */
          throw new Error('_remove<%=associations_temp[i].name_cp%> is not implemented in the model');
        }

        <%=associations_temp[i].name%>FilterImpl({search,order,pagination}){
          if(search === undefined)
          {
            return models.<%=associations_temp[i].target_lc%>.readAll({"field" : "<%=associations_temp[i].targetKey%>", "value":{"value":this.getIdValue() }, "operator": "eq"}, order, pagination);
          }else{
            return models.<%=associations_temp[i].target_lc%>.readAll({"operator":"and", "search":[ {"field" : "<%=associations_temp[i].targetKey%>", "value":{"value":this.getIdValue()}, "operator": "eq"} , search] }, order, pagination )
          }
        }

        countFiltered<%=associations_temp[i].name_cp%>Impl ({search}){

          if(search === undefined)
          {
            return models.<%=associations_temp[i].target_lc%>.countRecords({"field" : "<%=associations_temp[i].targetKey%>", "value":{"value":this.getIdValue() }, "operator": "eq"} );
          }else{
            return models.<%=associations_temp[i].target_lc%>.countRecords({"operator":"and", "search":[ {"field" : "<%=associations_temp[i].targetKey%>", "value":{"value":this.getIdValue() }, "operator": "eq"} , search] })
          }

        }

        <%=associations_temp[i].name%>ConnectionImpl({search,order,pagination}){
          if(search === undefined)
          {
            return models.<%=associations_temp[i].target_lc%>.readAllCursor({"field" : "<%=associations_temp[i].targetKey%>", "value":{"value":this.getIdValue() }, "operator": "eq"}, order, pagination);
          }else{
            return models.<%=associations_temp[i].target_lc%>.readAllCursor({"operator":"and", "search":[ {"field" : "<%=associations_temp[i].targetKey%>", "value":{"value":this.getIdValue() }, "operator": "eq"} , search] }, order, pagination )
          }
        }

      <%}-%>


      <% associations_temp = associations["belongsToMany"]-%>
      <% for(let i=0; i < associations_temp.length; i++){ -%>

        _add<%=associations_temp[i].name_cp%>(ids){
          YOUR CODE GOES HERE
          */
          throw new Error('_add<%=associations_temp[i].name_cp%> is not implemented in the model');

        }

        _remove<%=associations_temp[i].name_cp%>(ids){
          YOUR CODE GOES HERE
          */
          throw new Error('_remove<%=associations_temp[i].name_cp%> is not implemented in the model');

        }

        <%=associations_temp[i].name%>FilterImpl ({search,order,pagination}){
          /*
          YOUR CODE GOES HERE
          */
          throw new Error('<%=associations_temp[i].name%>FilterImpl is not implemented in the model');

        }

        countFiltered<%=associations_temp[i].name_cp%>Impl({search}){
          /*
          YOUR CODE GOES HERE
          */
          throw new Error('countFiltered<%=associations_temp[i].name_cp%>Impl is not implemented in the model');
        }

        <%=associations_temp[i].name%>ConnectionImpl ({search,order,pagination}){
          /*
          YOUR CODE GOES HERE
          */
          throw new Error('<%=associations_temp[i].name%>ConnectionImpl is not implemented in the model');

        }
      <%}-%>

  static get definition(){
    return definition;
  }

  static base64Decode(cursor){
    return Buffer.from(cursor, 'base64').toString('utf-8');
  }

  base64Enconde(){
    return Buffer.from(JSON.stringify(this.stripAssociations())).toString('base64');
  }

  stripAssociations(){
    let attributes = Object.keys(<%- name -%>.definition.attributes);
    attributes.push('id');
    let data_values = _.pick(this, attributes);
    return data_values;
  }

  /**
   * idAttribute - Check whether an attribute "internalId" is given in the JSON model. If not the standard "id" is used instead.
   *
   * @return {type} Name of the attribute that functions as an internalId
   */

  static idAttribute() {
    let internalId = <%- name -%>.definition.internalId === undefined ? "id" : <%- name -%>.definition.internalId;
    let idType = <%- name -%>.definition.attributes[internalId];

    if(internalId !== "id") {
      if(idType === undefined) {
        return new Error(`Attribute ${internalId} does not exist`)
      }
      if(!(idType === "String" || idType === "Int" || idType === "Float")) {
        return new Error(`Attribute ${internalId} must be of Type String, Int or Float`)
      }
    }
    
    return internalId; 
  }

  /**
   * idAttributeType - Return the Type of the internalId.
   *
   * @return {type} Type given in the JSON model 
   */

  static idAttributeType() {
    return <%- name -%>.definition.attributes[this.idAttribute()];  
  }

  /**
   * getIdValue - Get the value of the idAttribute ("id", or "internalId") for an instance of <%- name -%>.
   *
   * @return {type} id value 
   */

  getIdValue() {
    return this[<%- name -%>.idAttribute()]
  }


};
